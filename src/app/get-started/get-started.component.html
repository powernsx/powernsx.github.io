<main id="content-area" class="content-area" hash-listener #scrollable>
    <h1 id="installpowernsx">Getting Started with PowerNSX</h1>
    <p>PowerNSX is a PowerShell module that abstracts the VMware NSX API to a set of easily used PowerShell functions.
    </p>
    <p>This module is not supported by VMware, and comes with no warranties express or implied. Please test and validate its functionality before using this product in a production environment.
        
    It aims to focus on exposing New, Update, Remove and Get operations for all key NSX functions as well as adding additional functionality to extend the capabilities of NSX management beyond the native UI or API.
        
    <p>PowerNSX works closely with VMware PowerCLI, and PowerCLI users will feel quickly at home using PowerNSX.  Together these tools provide a comprehensive command line environment for managing your VMware NSX for vSphere environments.
    PowerNSX is still a work in progress, and it is unlikely that it will ever expose 100% of the NSX API.  Feature requests are welcome via the <a href="https://github.com/vmware/powernsx/issues">Issues</a> tracker on the projects GitHub page.</p>
    <p>    
    PowerNSX now supports PowerShell Core as of version 3.0.  Remember, PowerShell Core and PowerCLI Core are both pre-release products!.
    </p>
    <h2 id="masterInstall">Installing PowerNSX</h2>
    <p>PowerNSX can be installed through a number of methods. Getting started with PowerNSX is quick and efficient thanks to distribution via PowerShell Gallery. For macOS and Linux users this can be via the Install script or performed manually.

    With the release of PowerNSX version 3, PowerNSX is now available via the PowerShell Gallery. Installation is as simple as the following:</p>
            
    <clr-code-snippet
    [clrCode]="'Find-Module PowerNSX | Install-Module -scope CurrentUser'"
    [clrDisablePrism]="true">
    </clr-code-snippet>

    <p>Installation via PowerShell Gallery is only supported on Windows at this time. PowerShell Gallery is natively available on PowerShell 5 and above, and can be installed easily on earlier versions. See https://www.powershellgallery.com/ for more details

    Alternative methods for installation including installation on PowerShell Core (Linux, macOS) can be found below.
    </p>

    <h3 id="psgal">Install via PowerShell Gallery - Windows</h3>
    <p>Run the following in a PowerShell window to install PowerNSX for the current user. If PowerCLI is not installed, the required components are automatically downloaded and installed.
    
    PowerShell Gallery is the recommended method for Windows users. </p>
    
    <p>
    Run the following in a PowerShell window to install PowerNSX for the current user. If PowerCLI is not installed, the required components are automatically downloaded and installed.
    </p>

    <clr-code-snippet
    [clrCode]="'Find-Module PowerNSX | Install-Module -scope CurrentUser'"
    [clrDisablePrism]="true">
    </clr-code-snippet>
    
    To install for all users (requires PowerShell Run as Administrator):

    <clr-code-snippet
    [clrCode]="'Find-Module PowerNSX | Install-Module'"
    [clrDisablePrism]="true">
    </clr-code-snippet>

    Note: The master branch is not guaranteed to be stable. v3 is the current recommended stable release. PowerCLI 5.5 is no longer supported


    <h3 id="nsxinstallwindows">Auto Installer - Windows</h3>
    <p>The Installer script remains functional and supported for installation of PowerNSX version 3.0
            
    The following PowerShell oneliners will download and execute the PowerNSX installer and install the appropriate version. Allthough PowerShell 3 is required for PowerNSX, the installer script will run on PowerShell 2 and above, and will guide you through the process of installing all PowerNSX pre-requisites (including updating PowerShell.)
            
    Note: Internet access is required.</p>
    
    <p>Installing the latest stable branch - v3:</p>

    <clr-code-snippet [clrCode]="nsxAutoInstallWindowsMaster"></clr-code-snippet>
    
    Installing the master branch - active development branch:

    <clr-code-snippet [clrCode]="nsxAutoInstallWindowsV3"></clr-code-snippet>   
    
    <h3 id="manualInstallwindows">Manual Install - Windows</h3>
    <p>It is possible to install PowerNSX manually. The following pre-requisites must be met before the module will load successfully.</p>

    Latest stable - v3
    <table class="table">
            <thead>
                <tr>
                    <th class="left">Component</th>
                    <th>Minimum Version</th>
                    <th>Recommended Version</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="left">PowerShell</td>
                    <td>PowerShell 3</td>
                    <td>Powershell 4 (Win7-8.1, Server 2012/R2), PowerShell 5 (Win10, Server2016)</td>
                </tr>
                <tr>
                    <td class="left">DotNet</td>
                    <td>DotNet 4.5</td>
                    <td>DotNet 4.5</td>
                </tr>
                <tr>
                    <td class="left">PowerCLI</td>
                    <td>6.0R3</td>
                    <td>Latest in Gallery</td>
                </tr>
                <tr>
                    <td class="left">PowerNSX</td>
                    <td>v3</td>
                    <td>v3</td>
                </tr>
            </tbody>
        </table>
    
        <p>Install the listed pre-requisites, then download the chosen PowerNSX zip file and extract PowerNSX.psm1 and PowerNSX.psd1 from the module/platform/desktop folder to your PowerShell Modules directory. Recommended locations are:</p>
        <table class="table">
                <thead>
                    <tr>
                        <th class="left">Purpose</th>
                        <th>Path</th>
                    </tr>
                </thead>
                <tbody>
                    <tr>
                        <td class="left">All Users</td>
                        <td>%ProgramFiles%\Common Files\Modules\PowerNSX</td>
                    </tr>
                    <tr>
                        <td class="left">Current Users</td>
                        <td>%UserProfile%\Documents\WindowsPowerShell\Modules</td>
                    </tr>
                </tbody>
        </table>
    
        <p>If placed in a path included in $env:PSModulePath, then the module will automatically load, otherwise it will have to be manually imported using the Import-Module cmdlet. If manually loading, ensure the manifest (psd1) file is referenced, not the psm1.</p>
    
    <h3 id="nsxinstallmacoslinux">Auto Installer - macOS-Linux</h3>
    <p>Install the following pre-requisites manually.
            
    The PowerNSX team recommend PowerShell core 6.0.0-alpha18 for use with PowerNSX on macOS and Linux. There is a Powershell bug in 6.0.0-beta1 that breaks functionality for macOS and Linux. It can be downloaded <a href="https://github.com/PowerShell/PowerShell/releases/tag/v6.0.0-alpha.18">here</a></p>

    Installation of PowerNSX on macOS is basically the same as for Linux, except for the additional requirement of openssl support in curl that PowerShell and PowerCLI require. It is a common source of failure to overlook this, so ensure you take note of this when installing PowerShell as per the OSX instructions for doing so <a href="https://github.com/PowerShell/PowerShell/blob/master/docs/installation/linux.md#macos-1011">here</a>
    
    <p>Failure to address this will cause failures in both PowerCLI and PowerNSX.</p>

    <p>Pre-requisites for Latest Stable and Master</p>
    <table class="table">
            <thead>
                <tr>
                    <th class="left">Component</th>
                    <th>Minimum Version</th>
                    <th>Recommended Version</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="left">PowerShell</td>
                    <td><a href="https://github.com/PowerShell/PowerShell/releases/tag/v6.0.0-alpha.18">PowerShell Core alpha 18</a></td>
                    <td><a href="https://github.com/PowerShell/PowerShell/releases/tag/v6.0.0-alpha.18">PowerShell Core alpha 18</a></td>
                </tr>
                <tr>
                    <td class="left">PowerCLI Core</td>
                    <td><a href="https://labs.vmware.com/flings/powercli-core">1.0</a></td>
                    <td><a href="https://labs.vmware.com/flings/powercli-core">1.0</a></td>
                </tr>
            </tbody>
        </table>

    <p>The following PowerShell oneliner will download and execute the PowerNSX installer. The installer will automatically download the latest version of PowerNSX and place it in the appropriate PowerShell module directory.
            
    Note: Internet access is required</p>

    <p>Installing the latest stable branch - v3:</p>
    
    <clr-code-snippet [clrCode]="nsxAutoInstallMaclinMaster"></clr-code-snippet>
        
    Installing the master branch - active development branch:
    
    <clr-code-snippet [clrCode]="nsxAutoInstallMaclinV3"></clr-code-snippet> 

    <h3 id="manualInstallmacoslinux">Manual Install macOS-Linux</h3>
    <p>It is possible to install PowerNSX manually.</p>

    <p>Pre-requisites for Latest Stable and Master</p>
    <table class="table">
            <thead>
                <tr>
                    <th class="left">Component</th>
                    <th>Minimum Version</th>
                    <th>Recommended Version</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="left">PowerShell</td>
                    <td><a href="https://github.com/PowerShell/PowerShell/releases/tag/v6.0.0-alpha.18">PowerShell Core alpha 18</a></td>
                    <td><a href="https://github.com/PowerShell/PowerShell/releases/tag/v6.0.0-alpha.18">PowerShell Core alpha 18</a></td>
                </tr>
                <tr>
                    <td class="left">PowerCLI Core</td>
                    <td><a href="https://labs.vmware.com/flings/powercli-core">1.0</a></td>
                    <td><a href="https://labs.vmware.com/flings/powercli-core">1.0</a></td>
                </tr>
            </tbody>
        </table>

            
    <p>Install the above pre-requisites, then download the master branch PowerNSX zip file and extract PowerNSX.psm1 and PowerNSX.psd1 from the /module/platform/core/ directory to your PowerShell Modules directory within a directory named PowerNSX. Recommended locations are</p>
    <table class="table">
            <thead>
                <tr>
                    <th class="left">Purpose</th>
                    <th>Path</th>
                </tr>
            </thead>
            <tbody>
                <tr>
                    <td class="left">All Users</td>
                    <td>/usr/local/share/powershell/Modules</td>
                </tr>
                <tr>
                    <td class="left">Current Users</td>
                    <td>$($env:HOME)/.local/share/powershell/Modules</td>
                </tr>
            </tbody>
    </table>

    <p>If placed in a path included in $env:PSModulePath, then the module will automatically load, otherwise it will have to be manually imported using the Import-Module cmdlet. If manually loading, ensure the manifest (psd1) file is referenced, not the psm1.
    </p>
    
    
        <h3 id="InstallDocker">Docker Image</h3>
        <p>We are having a whale of a time. We're waiting for the vmware/PowerCliCore image maintainers to update the docker image</p>
    

   

    
        <h3 id="update">Updating PowerNSX</h3>
        <p>If PowerNSX is already installed, it can be updated to the master branch using the Update-PowerNSX cmdlet on either PowerShell Desktop or PowerShell Core.</p>
        <clr-code-snippet [clrCode]="'Update-PowerNSX -branch master'"></clr-code-snippet>
                
        <p>Note: The master branch is the active development branch of PowerNSX and is not guaranteed to be stable. You have been warned.
        Powershell Gallery based installations of PowerNSX cannot be updated using Update-PowerNSX. Use the following instead:</p>

        <clr-code-snippet [clrCode]="'Update-Module PowerNSX'"></clr-code-snippet>
           
   
    <h2 id="help">Finding Help</h2>

    <p>PowerShell features a powerful documentation and usage framwork for all cmdlets. The PowerNSX team seek to ensure documentation around each cmdlet is thorough and complete. Below outlines how to take advantage of this.</p>

        <h3 id="gethelp">Using Get Help</h3>
        <p>The cmdlet Get-Help can be used to determine how to use a given cmdlet. It provides details around the following:</p>
            <ul>
                <li>Name</li>
                <li>Synopsis</li>
                <li>Syntax</li>
                <li>Description</li>
                <li>Related Links</li>
                <li>Remarks</li>
            </ul>
         <p>These fields provide basic overview of the cmdlet. The output of Get-Help New-NsxIpSet below demonstrates this.
        </p>

        <clr-code-snippet [clrCode]="nsxHelpIpset"></clr-code-snippet>


        <h3 id="gethelpexamples">Get Help examples</h3>
        <p>There is nothing quite like an example to solidify a concept. The example output for a cmdlet demonstrates how a cmdlet can be used in numerous ways. Using the -Examples property you can view the examples for the cmdlet.</p>

        <clr-code-snippet [clrCode]="nsxHelpIpsetExamples"></clr-code-snippet>
        

        

    <h2 id="UsageExample">Using PowerNSX</h2>
    <p>The free PowerNSX <a href="https://www.vmware.com/content/dam/digitalmarketing/vmware/en/pdf/products/nsx/vmware-automating-vsphere-with-powernsx.pdf">digital book</a> by VMware Press provides in detail examples and information regarding PowerNSX. The book serves as an additional reference in conjunction with the output provided by <a href="/get-started#help">Get-Help</a> within PowerNSX.
            
    For usage details of common functional areas, refer to the following pages. For TL;DR, see below.</p>

    <h2 id="connect">Connecting to NSX</h2>

    <p>Administrators can take advantage of SSO or a direct connection to ensure the right level of access is granted when using the NSX Manager API. With a connection established to vCenter and NSX Manager an administrator can now perform operations with PowerNSX.</p>

        <h3 id="connectsso">Connecting with SSO accounts</h3>
        <p>Connecting with an SSO account requires explicit definition of the vCenter server. The account connecting to vCenter will be used to connect to the NSX API. This will create both a PowerCLI and PowerNSX session. SSO permissions applied to the account are enforced.</p>

        <clr-code-snippet [clrCode]="nsxConnectSso"></clr-code-snippet>
        

        <h3 id="connectlocal">Connecting with local account</h3>
        <p>Connecting directly with a local account to NSX Manager not recommended. Utilising SSO as demonstrated <a href="/get-started#connectsso">above</a> will ensure correct permissions. The local account for NSX Manager has full permissions with API usage.</p>

        <clr-code-snippet [clrCode]="nsxConnectLocal"></clr-code-snippet>
        
        
        <h3 id="disconnectnsx">Disconnecting from NSX</h3>
        <p> Closing a session is achieved by disconnecting from the NSX Manager</p>

        <clr-code-snippet [clrCode]="'Disconnect-NsxServer'"></clr-code-snippet>
        
        
    

    <h2 id="ls">Logical Switching</h2>
    
        <h3 id="getls">Retrieving Logical Switches</h3>
        <p>Logical Switches are bound to a Transport Zone. The following command runs the Get-NsxTransportZone for transport zone TZ1 and passes the Transport Zone object to Get-NsxLogicalSwitch which will return the logical switch named TSTransit in TZ1</p>

        <clr-code-snippet [clrCode]="nsxLsGet"></clr-code-snippet>

        <p>The output details a lot of information about the individual logical switch.
        To filter the properties of a Logical Switch output to a subset and view it in a table, we can use Select-Object cmdlet.</p>

        <clr-code-snippet [clrCode]="nsxLsGetSelect"></clr-code-snippet>
    
        <h3 id="newls">Creating Logical Switches</h3>
        <p>Using the above method it is quite easy to create a Logical Switch in the transport zone TZ1 using the New-NsxLogicalSwitch command. It only requires the Transport Zone passed on the pipeline, and the Logical Switch name as an input.</p>

        <clr-code-snippet [clrCode]="nsxLsNew"></clr-code-snippet>

        <h3 id="lspg">Retrieving a Logical Switch Backing PortGroup</h3>
        <p>Each Logical Switch is backed by a port-group on one or more Distributed Switches, and the port group is the entity that a VM is actually attached to. To retrieve the port group(s) backing a Logical Switch, you can use the Get-NsxBackingPortGroup cmdlet.</p>

        <clr-code-snippet [clrCode]="nsxLsPg"></clr-code-snippet>
        
        <p>Here we can see the port-group name vxw-dvs-44-virtualwire-516-sid-5000-PowerNSX which is the Logical Switch we created earlier.
            
        <b>Note:</b> In a multi VDS environment, a single logicalswitch will be backed by multiple portgroups. This command will correctly return a collection of VDPortGroup objects. If you wish to use them subsequently (say to attach a VM to them) you will need to filter the collection accordingly (say by cluster)</p>

        <h3 id="attachvm">Attaching a VM</h3>

        <p>Using PowerCLI to retrieve a VM (or number of VMs) it is possible to subsequently attach them to an NSX Logical Switch. This uses the Connect-NsxLogicalSwitch cmdlet when receiving VM's from the pipeline.</p>

        <clr-code-snippet [clrCode]="nsxLsVmAttach"></clr-code-snippet>
        
        
        <h3 id="detachvm">Detaching a VM</h3>

        <p>In similar fashion to attaching a VM, you can also detach a VM using the Disconnect-NsxLogicalSwitch cmdlet when receiving VMs from the pipeline.</p>
        <clr-code-snippet [clrCode]="nsxLsVmDetach"></clr-code-snippet>

        <p>The VMs now have no port-group attached to the NIC. Use -DisconnectMultipleNics if a machine has more than one.</p>
        <h3 id="removels">Removing Logical Swiches</h3>
        <p>Removing a Logical Switch can be performed by passing the desired Logical Switches along the pipeline.</p>

        <clr-code-snippet [clrCode]="nsxLsRemove"></clr-code-snippet>
        

    <h2 id="dlr">Logical Routing</h2>
    <p>The NSX DLR allows for Layer 3 forwarding decisions to occur within the hypervisor. This provides east west routing as well as north bound routing with an NSX Edge Gateway.</p>
        
        <h3 id="dlrint">Defining LIF Specs</h3>   
        <p>Defining Logical Interfaces (LIFs) on a DLR individually is basically the same process as it is for the NSX Edge. Each individual interface can be pre-configured using the New-NsxLogicalRouterInterfaceSpec cmdlet. This allows Logical Interfaces or LIFs to be defined ahead of creation of the DLS. At least one LIF is required on initial deployment of DLR control VM. The below example defines an uplink LIF and then deploys the DLR control VM to the defined Cluster.</p>

        <clr-code-snippet [clrCode]="nsxDlrLif"></clr-code-snippet>

        Note: All this cmdlet is doing is defining the correct XML for the subsequent New-NsxLogicalRouter cmdlet. The NSX API is not used when using the New-NsxLogicalRouterInterfaceSpec cmdlet. The variable has the details for the new LIF.

        <h3 id="dlrcreate">Deploying a DLR</h3>
        <p>An arbitrary number of pre-configured LIFs created with New-NsxLogicalRouterInterfaceSpec and stored as variables can then be used when creating a new DLR. If you have more than one interface to specify, do so as a comma separated list argument to the -Interface parameter of the New-NsxLogicalRouter cmdlet.</p>

        <clr-code-snippet [clrCode]="nsxDlrDeploy"></clr-code-snippet>
        

        <h3 id="dlrlifappend">Appending another interface</h3>
        <p>Here we are going to add a new interface to the DLR without using the spec. We will use the `New-NsxLogicalRouterInterface` cmdlet to add it to the recently created DLR.</p>

        <clr-code-snippet [clrCode]="nsxDlrAppendLif"></clr-code-snippet>

        <p>It is a straightforward method of adding new interfaces.</p>

        <h3 id="dlrlifremove">Removing a DLR LIF</h3>
        <p>There may come a time where a LIF is no longer needed. It can be removed with the use of the Remove-NsxLogicalRouterInterface cmdlet.</p>

        <clr-code-snippet [clrCode]="nsxDlrRemoveLif"></clr-code-snippet>

        The specific DLR and specified interface is passed along the pipeline to the remove cmdlet. An administrator can use -confirm:$false if the prompt needs to be skipped.

        <h3 id="dlrremove">Removing a DLR</h3>

        <p>The DLR passed along the pipeline from Get-NsxLogicalRouter will be removed.</p>

        <clr-code-snippet [clrCode]="nsxDlrRemove"></clr-code-snippet>
        
       <p>The DLR is now removed completely.</p>

        <h3 id="dlrbgp">BGP routing on a DLR</h3>
        <p> Configuring BGP on a DLR is straight forward. It requires the following steps:</p>
        <ul>
            <li>Enabling the BGP Routing process</li>
            <li>Defining BGP Peers</li>
            <li>Configuring redistribution as required</li>
        </ul>
        <p>Below enables the BGP process for the DLR</p>
        <clr-code-snippet [clrCode]="nsxDlrBgp"></clr-code-snippet>
        
        <h3 id="dlrbgpneighbor">BGP Neighbors a DLR</h3>
        <p> The definition of a BGP is required. The BGP peer is between the control planes of the respective components.</p>
        <clr-code-snippet [clrCode]="nsxDlrBgpNeighbor"></clr-code-snippet>
        <p>If the upstream peer is configured then peering will commence.</p>

        <h3 id="dlrbgpredist">Route Redistribution in BGP</h3>
        <p> Route redisitrbution needs to be enabled globally for the DLR. This will enable any redistribution rules configured</p>
        <clr-code-snippet [clrCode]="nsxDlrBgpRedist"></clr-code-snippet>

        <h3 id="dlrbgpredistconn"> Redistribute connected in BGP</h3>
        <p>A DLR Logical Inteface (LIF) is a directly connected interface. Redistributing these LIFs will ensure network advertisement to upstream BGP peers.</p>
        <clr-code-snippet [clrCode]="nsxDlrBgpRedistConn"></clr-code-snippet>
        
        
        <h3 id="dlrospf">Enabling OSPF</h3>
        <p>OSPF is an alterntive to BGP. Configuring OSPF is similar to BGP and straight forward. It requires the following steps:</p>
        <ul>
            <li>Enabling the OSPF Routing process</li>
            <li>Configure OSPF Areas</li>
            <li>Add an interface to an OSPF area.</li>
            <li>Redistribute into OSPF</li>
        </ul>
        <p>Once OSPF is enabled it is enabled for the entire DLR.</p>
        <clr-code-snippet [clrCode]="nsxDlrOspf"></clr-code-snippet>
        
        <h3 id="dlrospfarea">OSPF Areas on DLR</h3>
        <p>The concept of OSPF areas indicate the span of routers particpating in this area of OSPF. Below defines an area and type.</p>
        <clr-code-snippet [clrCode]="nsxDlrOspfArea"></clr-code-snippet>
        
        <h3 id="dlrospfinterface">OSPF interfaces on DLR</h3>
        <p>The cmdlets below add the uplink interface into OSPF</p>
        <clr-code-snippet [clrCode]="nsxDlrOspfInterface"></clr-code-snippet>
        
        

        <h3 id="dlrstatic">Static routing on a DLR</h3>
        <p>There are times where static routing is needed. Static routing can be simply configured for a given Edge or DLR. </p>
        <clr-code-snippet [clrCode]="nsxDlrStatic"></clr-code-snippet>
        
        
        
    <h2 id="dfw">Distributed Firewall</h2>
    <p>Here are some quick tips for working with the Distributed Firewall</p>

        <h3 id="dfwsection">Working with DFW Sections</h3>

        <p>The Distributed Firewall is section based and the CRUD operations around Distributed Firewall hinge on operating with sections. First step is to retrieve a defined section.</p>
        <clr-code-snippet [clrCode]="nsxDfwSectionGet"></clr-code-snippet>
        
        <p>The output of this command returns a firewall section named exactly 'Management - Web Services'. Creating a section is straight forward. It is a simple cmdlet demonstrated below. Let's create a new section to keep them in.</p>
        
        <clr-code-snippet [clrCode]="nsxDfwSectionCreate"></clr-code-snippet>
        
        
        <h3 id="dfwruleget">Retrieving DFW Rules</h3>

        <p>Based on the output above in DFW Sections, you can see that it is a Layer 3 section and that it has some rules associated with it. To find out more about the rules associated to with it we can use the Get-NsxFirewallRule.</p>
        <clr-code-snippet [clrCode]="nsxDfwRuleGet"></clr-code-snippet>
        <p>The Powershell pipeline takes the object passed to it from Get-NsxFirewallSection, in this case, 'Management - Web Services' and uses it in the Get-NsxFirewallRule command. There are two rules associated with this section - ruleId 1106 and 1107.</p>
        >

        <h3 id="dfwrulecreate">Retrieving DFW Rules</h3>
        <p>Creating a new rule is striaght forward. It requires a section to be passed along the pipeline to the New-NsxFirewallRule cmdlet.</p>
        <clr-code-snippet [clrCode]="nsxDfwRuleCreate"></clr-code-snippet>
        <p>Let us walk through the above example. Using the two stored variables for source and destination, `Get-NsxFirewallSection` first retrieves the defined firewall section. It then passes the section object along the pipeline to `New-NsxFirewallRule`. `New-NsxFirewallRule` receives the object from the pipeline, and proceeds to create a rule within it. As well as passing in variables defining Source and Destination, you can also see we are specifying the service, action, logging status, and DFW tag.</p>
        
        <h3 id="dfwappliedto">Using DFW Applied To</h3>
        <p>We're still working to add content. Please refer to the PowerNSX book or the <a href="./get-started#gethelp">Get Help</a> cmdlet for further details.</p>

        <h3 id="dfwexclusion">Creating DFW Exclusions</h3>
        <p>It is possible to remove the Distributed Firewall filter using an Exclusion list. This example below shows the exemption of the VM Web-02</p>

        <clr-code-snippet [clrCode]="nsxDfwExclusion"></clr-code-snippet>
        
        <p>This will add the defined Virtual Machine to the DFW exclusion list.</p>
        

    <h2 id="security">Security Objects</h2>
    <p>Security Groups and Security Tags provide a powerful asset to the Distributed Firewall and Security Operations in NSX for vSphere</p>

        <h3 id="sectagcreate">Creating Security Tags</h3>
        <p>It is easy and quick to create a Security Tag. Below demonstrates this:</p>
        <clr-code-snippet [clrCode]="nsxSecTagCreate"></clr-code-snippet>
        <p>By creating a security tag that is not a system default it is now possible to retrieve it. By default, PowerNSX will not retrieve the dozen system-generated security tags. This can be overridden with -IncludeSystem. Use Get-NsxSecurityTag to retrieve user configured Security Tags</p>
        
        <h3 id="sectagget">Retrieving Security Tags</h3>
        <p> Working with Security Tags involves simple CRUD operations. Below retrieves the Security Tags</p>
        <clr-code-snippet [clrCode]="nsxSecTagGet"></clr-code-snippet>

        <h3 id="sectagapply">Applying Security Tags</h3>
        <p>Once retrieved these tags can be used to apply to Virtual Machines or as members of Security Groups.</p>
        <clr-code-snippet [clrCode]="nsxSecTagApplyVM"></clr-code-snippet>
        
        <h3 id="secgroupcreate">Creating Security Groups</h3>
        <p>Creating a new Security Group is simple with PowerNSX. Either empty groups or groups with included or excluded members can be done. The object passed to -IncludeMember or -ExcludeMember can be the vCenter objects references in the UI.
        Lets use an NSX security tag as the include criteria.</p>
        <clr-code-snippet [clrCode]="nsxSecGroupCreate"></clr-code-snippet>
        <p>Now to apply the Security Tag to a given VM. The first is to find the Virtual Machine Web-02.</p>
        <clr-code-snippet [clrCode]="nsxSecTagApplyVM"></clr-code-snippet>
        <p>Now that the Virtual Machines are tagged with a specific Security Tag they become a member of the associated Security Group.</p>

        <h3 id="secgroupget">Retrieving Security Groups</h3>
        <p>Let's list all created Security Groups by selecting the desired properties to list and formatting it to a nice table.</p>
        <clr-code-snippet [clrCode]="nsxSecGroupGet"></clr-code-snippet>

        <h3 id="secpol">Security Policies</h3>
        <p>Examples coming soon. Please use Get-Help in the mean time. </p>   
        
        <h3 id="servicecreate">Creating Services</h3>
        <p>Creating a service requires very basic information about protocol and ports.</p>
        <clr-code-snippet [clrCode]="nsxSecServiceCreate"></clr-code-snippet> 

        <h3 id="servicegroupcreate">Creating Service Groups</h3>
        <p>Service Groups are a container that holds other Services or Service Groups</p>
        <clr-code-snippet [clrCode]="nsxSecServiceGroupCreate"></clr-code-snippet> 
             
        <h3 id="servicegroupmemberadd">Adding Service Group members</h3>
        <p>Now that the Service Group has been made it is time to add some members to it. This example uses two services - tcp-80 and tcp-443 that have already been created.</p> 
        <clr-code-snippet [clrCode]="nsxSecServiceGroupAddMember"></clr-code-snippet>  

        <h3 id="servicegroupmemberget">Retrieving Service Group members</h3>
        <p>What about retreiving services included in a specific Service Group?  The PoSH pipeline has you covered. Just get the Service Group with Get-NsxServiceGroup and pipe it to Get-NsxServiceGroupMembers.</p>
        <clr-code-snippet [clrCode]="nsxSecServiceGroupMember"></clr-code-snippet>
        
        <h2 id="esg">NSX Edge Services Gateway</h2>
        <p>The NSX Edge is a Virtual Machine that provides Routing, Edge Firewalling, Load Balancing, SSL VPN, IPSEC VPN, Bridging, and DHCP functions.  The NSX Edge represents a huge part of the NSX API due to its swiss army knife capabilities.  Most of the common features are supported by PowerNSX.</p>

                <h3 id="esginterface">Edge Interface creation</h3>
                <p>To deploy a new Edge, we first have to build the Edge interface specification.
                Lets create an uplink interface and store it in the $uplink variable.</p>
                <clr-code-snippet [clrCode]="nsxEsgInterface"></clr-code-snippet>

                <h3 id="esgdeploy">Deplying an Edge</h3>
                <p>Now to create a new compact NSX edge. This will take some time as the OVA is deployed from NSX Manager to the defined cluster and datastore. The Edge is started and then configured by NSX. This example has also enabled the Edge Firewall and turned on AutoGenerateRules. Upon successful completion the newly created edge object is returned.</p>
                <clr-code-snippet [clrCode]="nsxEsgDeploy"></clr-code-snippet>

                <h3 id="esginterfacevalidation">Validating Edge Interfaces</h3>
                <p>By default the NSX edge has 10 interfaces. When not used they are idle. When issuing a Get-NsxEdgeInterface command it will return all connected and disconnected interfaces.
                        
                It is possible to pipe the results and use Where-Object (?) to filter the output. The property isConnected is key here. ? {{'{'}}_.isConnected -eq ("true"){{'}'}} performs filtering on the property isConnected. It will return all Edge interfaces with the value of true in the isConnected property.
                        
                Using Where-Object (?) is a core PowerShell function.</p>
                <clr-code-snippet [clrCode]="nsxEsgInterfaceValidate"></clr-code-snippet>
                

                <h3 id="esgbgp">Enabling Edge BGP</h3>
                <p>Enabling BGP on an ESG requires less steps than a DLR. First step is enabling BGP. </p>
                <clr-code-snippet [clrCode]="nsxEsgBgp"></clr-code-snippet>

                <h3 id="esgbgpneighbor">Configuring BGP neighbors</h3>
                <p>Once BGP is enabled you then must configure neighbors to peer with. </p>
                <clr-code-snippet [clrCode]="nsxEsgBgpNeighbor"></clr-code-snippet>

                <h3 id="esgospf">Enabling OSPF on an Edge</h3>
                <p>Enabling OSPF on an NSX Edge is demonstrated below. </p>
                <clr-code-snippet [clrCode]="nsxEsgOspf"></clr-code-snippet>

                <h3 id="esgospfarea">Configuring Edge OSPF Areas</h3>
                <p>Creation of OSPF Areas is required.</p>
                <clr-code-snippet [clrCode]="nsxEsgOspfArea"></clr-code-snippet>

                <h3 id="esgospfinterface">Configuring Edge OSPF interfaces</h3>
                <p>Once OSPF is enabled and desired areas are created then configure Edge Interfaces into OSPF areas.</p>
                <clr-code-snippet [clrCode]="nsxEsgOspfInterface"></clr-code-snippet>
        
                <h3 id="esgstatic">Static routing on a ESG</h3>
                <p>There are times where static routing is needed. Static routing can be simply configured for a given Edge or DLR. </p>
                <clr-code-snippet [clrCode]="nsxEsgStatic"></clr-code-snippet>

                <h3 id="esgfirewall">Firewall on ESG</h3>
                <p>Coming Soon! </p>

    
    <h2 id="lb">NSX Edge Load Balancer</h2>
    <p>Any NSX Edge can be provide Load Balancing functionality. Discover how to automate and create this below with PowerNSX</p>
    
        <h3 id="lbconfigure">Enabling NSX Edge Load Balancing</h3>
        <p>The following command will retrieve the NSX Edge named PowerNSX, Get and subsequently enable the load balancer. This will also turn on logging. Logging will use the existing NSX Edges defined Syslog settings.</p>
        <clr-code-snippet [clrCode]="nsxLbEnable"></clr-code-snippet>        
        <p>With the Load Balancer service now running on the Edge PowerNSX it is time now to create all the other desired elements such as Pools, Service Monitors, Application Profiles, and Virtual Servers.</p>
        
        <h3 id="lbpool">oad Balancer Pools and Members</h3>
        <p>Defining Pool members is very much like NSX Edge interfaces. They are defined seperately and then referenced in pool creation. Below defines three members for a Web Pool then creates a round-robined Pool with a http monitor applied.</p>
        <clr-code-snippet [clrCode]="nsxLbPool"></clr-code-snippet>        
        <p>The result is a Pool with 3 Members, a configured algorithm, and a monitor.</p>
       
        <h3 id="lbapp">Load Balancer App Profiles</h3>
        <p>Creating an Application Profile determines what traffic type is interesting for the Load Balancer to listen to on the Virtual Server.</p>
        <clr-code-snippet [clrCode]="nsxLbApp"></clr-code-snippet>        
        <p>If NAT is being used and the original IP is required in header then then -insertXForwardedFor can be used.</p>
        
        <h3 id="lbvip">Load Balancer Virtual Servers</h3>
        <p>Creating a Virtual Server requires a pre-defined Application Profile and an optional Pool. It is recommended a pool be attached at creation.</p>
        <clr-code-snippet [clrCode]="nsxLbVip"></clr-code-snippet>        
        
        <p>The above code has created a Virtual Server listening on 192.168.100.40 (vNic_0 Uplink). The assigned Application profile enables listening on HTTP for traffic. The defined port is on the Virtual Server.</p>

        <h3 id="lbmon">Load Balancer Monitors</h3>
        <p>Monitors can be created to support generic and specific application requirements. Here is a custom monitor created for vRealize Automation 7.1</p>
        <clr-code-snippet [clrCode]="nsxLbMon"></clr-code-snippet>        
        <p>This monitor performs a specifc URL check against /VMPSProvision on the vRealize Automation Manager service.</p>
        <h3 id="lbrecipes">Load Balancer recipes</h3>
        <p>Check back for LB reciples created with PowerNSX for common applications</p>
        

    


    <h2 id="contributing">Contributing to PowerNSX</h2>
    <p>Contribution and feature requests are more than welcome, please use the following methods:</p>
        <ul>
            <li>For bugs and issues, please use the <a href="https://github.com/vmware/powernsx/issues">Issues</a> register with details of the problem.</li>
            <li>For Feature Requests, please use the <a href="https://github.com/vmware/powernsx/issues">Issues</a>  register with details of what's required.</li>
            <li>To contribute code, create a fork, make your changes in a feature branch and submit a pull request.</li>
        </ul>     
        <h3 id="contest">Testing PowerNSX</h3>
        <p>
            As of now, PowerNSX has a (still incomplete) formal test suite.  In order to develop additional features, contribution of corresponding tests is requested.
            
            Tests are organised under functional section in the tests/ directory.  Pester is the test framework used.  Any contribution of tests for existing functionality is greatly appreciated!
            
            If you make modifications to PowerNSX, ensure the current test set completes successfully, as well as including tests for your new functionality or fixes before submitting a pull request.
            
            In the near future, these tests will be the foundation of CI tests that are automatically executed before a PR can be merged.
        </p>

        <h3 id="conprereq">Pre-Requisites</h3>
        <p>
            All tests require a 'sacrifical' NSX environment.  Internally we use labs running nested vSphere/NSX environments, but any functional NSX environment will be suitable.
            
            *Do not execute tests agains a production or important NSX environment.  Duh!*
            
            Existing tests do not indescriminantly delete/modify existing configuration, but care should be taken, and isolated and disposable NSX environments are recommended for this purpose!
            
            In order to execute tests, the NSX environment should be configured as follows:
        </p>
        <ul>
            <li>NSX Manager Deployed</li>
            <li>A single Transport Zone consisting of at least one cluster of at least one ESXi host.</li>
            <li>A functional NSX control plane (at least one controller deployed and functional)</li>
            <li>Pester (The PowerShell testing tool) Installed.  (Included by default on Win10/PoSH 5)</li>
        </ul>
        <p>These are the required modules for the tests</p>
        <ul>
                <li><a href="https://github.com/pester/Pester">Pester</a></li>
                <li><a href="https://www.powershellgallery.com/"></a>PowerShellGet</li>
        </ul>

        <p>The Test Module is the same for both Core and Full versions of PowerNSX, but the manifest is dfferent to deal with different module prerequisites.  The TestCore.Psd1 manifest references Test.Psm1 module.
                
                You must import the Test manifest (psd1), not the module itself (psm1)</p>
        <h3 id="conexec">Executing Tests</h3>
        <p>Assuming you have git cloned the powernsx repository, cd into the repository, launch powershell, import the test module and initiate the tests using the Start-Test function.  Running Start-Test without any arguments will execute most PowerNSX tests (in future some tests will be excluded from default runs for a variety of reasons).
                
        Example (Desktop/Full version of PowerShell on Windows), Current working directory is the root folder of the powernsx repository :</p>

        <clr-code-snipper [clrCode]="nsxContributeTestCore"></clr-code-snipper>

        <h3 id="conindtest">Executing Individual Tests</h3>
        <p>Tests are broken up according to functional area.  If you are working on NAT functionality for instance, its possible to just run NAT related tests.  The name of the functional area is defined within the 'Describing' block within the test file.  You can pass this string as the only argument to the Start-Test function to execute those tests in isolation.
                
        Example:</p>

        <clr-code-snippet
        [clrCode]="'Start-Test "Edge NAT"'"
        [clrDisablePrism]="true">
        </clr-code-snippet>        

        <p>The first time tests are executed, default connection details are prompted for and optionally saved to disk.  These can be overridden by deleting the Test.cxn file in the tests directory if it becomes necessary to reconfigure them.  Currently these credentials are stored in CLEAR TEXT.  See Known Issues for details.</p>
        
        <h3 id="known">Known Issues</h3>
        <p>Due to module dependancy and module autoloading functionality in PowerShell, tests should be executed from a new PowerShell session, and preferably without existing PowerNSX or PowerCLI modules loaded for consistent results.  Tests will automatically load the PowerNSX module within the current repository for testing (not the module from the default Module path!) so easy testing of development changes to the module can be performed.
                
        You must launch tests using the Start-Test function, and *must not* use Invoke-Pester or individual test execution to perform tests.  This action is blocked intentionally, again due to module loading prerequisites.
                
        Due to a limitation in ConvertFrom-SecureString on PowerShell Core, credentials specified for testing will be persisted to disk in an insecure manner.  This will be resolved as soon as the underlying issue in ConvertFrom-SecureString is.</p>
        

    <h2 id="issue">Reporting an Issue</h2>
    <p>Ongoing work and feature requests are tracked using <a href="https://github.com/vmware/powernsx/issues" target="_blank">GitHub Issues</a>. Please feel free to
        file an issue.
    </p>
    <div style="visibility: hidden; height: 80vh;">This is a spacer to force sidenav highlighting on scroll</div>
</main>
<nav class="sidenav" [clr-nav-level]="2">
    <section class="sidenav-content">
        <section class="nav-group" [scrollspy]="scrollable">
            <label><a class="nav-link active" routerLink="." fragment="installpowernsx">Getting Started </a></label>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="masterInstall">Installing PowerNSX</a></label>
            <ul class="nav-list">
                <li><a class="nav-link" routerLink="." fragment="psgal">Powershell Gallery Installer - Windows</a></li>
                <li><a class="nav-link" routerLink="." fragment="nsxinstallwindows">Auto Installer - Windows</a></li>
                <li><a class="nav-link" routerLink="." fragment="manualInstallwindows">Manual Install - Windows</a></li>                
                <li><a class="nav-link" routerLink="." fragment="nsxinstallmacoslinux">Auto Installer - macOS-Linux</a></li>
                <li><a class="nav-link" routerLink="." fragment="manualInstallmacoslinux">Manual Install - macOS-Linux</a></li>     
                <li><a class="nav-link" routerLink="." fragment="InstallDocker">Using Docker</a></li>     
                <li><a class="nav-link" routerLink="." fragment="update">Updating PowerNSX</a></li>   
            </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="help">Finding Help</a></label>
                <ul class="nav-list">
                    <li><a class="nav-link" routerLink="." fragment="gethelp">Using Get-Help</a></li>
                    <li><a class="nav-link" routerLink="." fragment="gethelpexamples">Finding cmdlet examples</a></li>
                </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="UsageExample">Using PowerNSX</a></label>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="connect">Connecting to NSX</a></label>
            <ul class="nav-list">
                    <li><a class="nav-link" routerLink="." fragment="connectsso">Connect with SSO accounts</a></li>
                    <li><a class="nav-link" routerLink="." fragment="connectlocal">Connect with local account</a></li>
                    <li><a class="nav-link" routerLink="." fragment="disconnectnsx">Disconnect from NSX</a></li>
            </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="ls">Logical Switching</a></label>
                <ul class="nav-list">
                    <li><a class="nav-link" routerLink="." fragment="getls">Retrieving a Logical Switch</a></li>                        
                    <li><a class="nav-link" routerLink="." fragment="newls">Creating a Logical Switch</a></li>
                    <li><a class="nav-link" routerLink="." fragment="lspg">Determine backing Port Group</a></li>                        
                    <li><a class="nav-link" routerLink="." fragment="attachvm">Attaching a VM</a></li>                        
                    <li><a class="nav-link" routerLink="." fragment="removels">Removing a Logical Switch</a></li>
            </ul>
           
            
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="dlr">Logical Routing</a></label>
            <ul class="nav-list">
                    <li><a class="nav-link" routerLink="." fragment="dlrint">Defining an interface spec</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrcreate">Creating a new DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrlifappend">Appending another interface</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrlifremove">Removing an interface</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrdelete">Removing a DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrbgp">BGP routing on a DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrbgpneighbor">BGP Neighbors on DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrbgpredist">Route Redistribution in BGP</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrospf">Enabling OSPF</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrospfarea">OSPF Areas on DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrospfinterface">OSPF particpation on DLR</a></li>
                    <li><a class="nav-link" routerLink="." fragment="dlrospfredist">Route Redistribution in OSPF</a></li>
            </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="dfw">Distributed Firewall</a></label>
                <ul class="nav-list"> 
                        <li><a class="nav-link" routerLink="." fragment="dfwsection">Working with DFW Sections</a></li>
                        <li><a class="nav-link" routerLink="." fragment="dfwruleget">Retrieving DFW Rules</a></li>
                        <li><a class="nav-link" routerLink="." fragment="dfwrulecreate">Creating DFW Rules</a></li>
                        <li><a class="nav-link" routerLink="." fragment="dfwappliedto">Using DFW Applied To</a></li>
                        <li><a class="nav-link" routerLink="." fragment="dfwexclusion">Creating DFW Exclusions</a></li>                        
                        
                </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="security">Security Objects</a></label>
                <ul class="nav-list"> 
                        <li><a class="nav-link" routerLink="." fragment="sectagcreate">Creating Security Tags</a></li>
                        <li><a class="nav-link" routerLink="." fragment="sectagget">Retrieving Security Tags</a></li>        
                        <li><a class="nav-link" routerLink="." fragment="sectagapply">Attaching Security Tags</a></li> 
                        <li><a class="nav-link" routerLink="." fragment="secgroupcreate">Creating Security Groups</a></li>
                        <li><a class="nav-link" routerLink="." fragment="secpol">Security Policies</a></li>                        
                        <li><a class="nav-link" routerLink="." fragment="servicecreate">Creating Services</a></li>   
                        <li><a class="nav-link" routerLink="." fragment="servicegroupcreate">Creating Service Groups</a></li>
                        <li><a class="nav-link" routerLink="." fragment="servicegroupmemberadd">Adding Service Group members</a></li> 
                        <li><a class="nav-link" routerLink="." fragment="servicegroupmemberget">Retrieving Service Group members</a></li>      
                </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="esg">NSX Edge Services Gateway</a></label>
                <ul class="nav-list">
                        <li><a class="nav-link" routerLink="." fragment="esginterface">Edge Interface creation</a></li> 
                        <li><a class="nav-link" routerLink="." fragment="esgdeploy">Deploying an Edge </a></li>
                        <li><a class="nav-link" routerLink="." fragment="esginterfacevalidation">Validating Edge Interfaces</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgbgp">Enabling BGP on Edge</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgbgpneighbor">Configuring BGP neighbors</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgospf">Enabling OSPF on Edge</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgospfarea">Configuring OSPF Areas</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgospfinterface">Configuring OSPF Interfaces</a></li>
                        <li><a class="nav-link" routerLink="." fragment="esgstatic">Static routing on an ESG</a></li>                                                 
                        <li><a class="nav-link" routerLink="." fragment="esgfirewall">Configure Edge Firewall</a></li>
                </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="lb">NSX Edge Load Balancer</a></label>
                <ul class="nav-list"> 
                        <li><a class="nav-link" routerLink="." fragment="lbconfigure">Enabling Load Balancing</a></li>
                        <li><a class="nav-link" routerLink="." fragment="lbpool">Load Balancer Pools and Members</a></li>
                        <li><a class="nav-link" routerLink="." fragment="lbapp">Load Balancer App Profiles</a></li>
                        <li><a class="nav-link" routerLink="." fragment="lbvip">Load Balancer Virtual Servers</a></li>
                        <li><a class="nav-link" routerLink="." fragment="lbmon">Load Balancer Monitors</a></li>
                        <li><a class="nav-link" routerLink="." fragment="lbrecipes">Load Balancer recipes</a></li>                        
                </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="contributing">Contributing to PowerNSX</a></label>
            <ul class="nav-list"> 
                    <li><a class="nav-link" routerLink="." fragment="contest">Contributing to PowerNSX</a></li>
                    <li><a class="nav-link" routerLink="." fragment="conprereq">Pre-Requisites</a></li>
                    <li><a class="nav-link" routerLink="." fragment="conexec">Executing Tests</a></li>
                    <li><a class="nav-link" routerLink="." fragment="conindtest">Executing Individual Tests</a></li>
                    <li><a class="nav-link" routerLink="." fragment="known">Known Issues</a></li>
            </ul>
            <label class="bump-down"><a class="nav-link" routerLink="." fragment="issue">Reporting an Issue</a></label>
        </section>
    </section>
    </nav>
