/*
 * Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.
 * This software is released under MIT license.
 * The full license information can be found in LICENSE in the root directory of this project.
 */
import { Component, ContentChildren, ElementRef, EventEmitter, Input, IterableDiffers, Output } from "@angular/core";
import { GHOST_PAGE_ANIMATION } from "../modal/utils/ghost-page-animations";
import { ButtonHubService } from "./providers/button-hub";
import { HeaderActionService } from "./providers/header-actions";
import { PageCollectionService } from "./providers/page-collection";
// providers
import { WizardNavigationService } from "./providers/wizard-navigation";
import { WizardHeaderAction } from "./wizard-header-action";
import { WizardPage } from "./wizard-page";
/**
 * The Wizard component
 *
 * @export
 * @class Wizard
 * @implements {OnInit}
 * @implements {OnDestroy}
 * @implements {AfterContentInit}
 * @implements {DoCheck}
 */
var Wizard = (function () {
    /**
     * Creates an instance of Wizard.
     * @param {WizardNavigationService} navService
     * @param {PageCollectionService} pageCollection
     * @param {ButtonHubService} buttonService
     * @param {HeaderActionService} headerActionService
     * @param {ElementRef} elementRef
     * @param {IterableDiffers} differs
     *
     * @memberof Wizard
     */
    function Wizard(navService, pageCollection, buttonService, headerActionService, elementRef, differs) {
        var _this = this;
        this.navService = navService;
        this.pageCollection = pageCollection;
        this.buttonService = buttonService;
        this.headerActionService = headerActionService;
        this.elementRef = elementRef;
        this.differs = differs;
        /**
         * Contains the size defined by the clrWizardSize input
         * @name size
         * @type {string}
         * @default "xl"
         * @memberof Wizard
         */
        this.size = "xl";
        /**
         * The property that reveals the ghost pages in the wizard. Set through the
         * clrWizardShowGhostPages input.
         *
         * @name showGhostPages
         * @default false
         * @type {boolean}
         * @memberof Wizard
         */
        this.showGhostPages = false;
        this._forceForward = false;
        /**
         * Tells the modal part of the wizard whether it should have a close "X"
         * in the top right corner. Set with the clrWizardClosable input.
         *
         * @name closable
         * @type {boolean}
         * @memberof Wizard
         */
        this.closable = true;
        /**
         * Toggles open/close of the wizard component. Set using the clrWizardOpen
         * input.
         *
         * @name _open
         * @type {boolean}
         * @memberof Wizard
         */
        this._open = false;
        /**
         * Emits when the wizard is opened or closed. Emits through the
         * clrWizardOpenChange output. Works in conjunction with the
         * clrWizardOpen binding so you can use...
         *
         * <clr-wizard [(clrWizardOpen)]="blah"
         * ...or...
         * <clr-wizard [clrWizardOpen]="something" (clrWizardOpenChange)="doSomethign($event)">
         *
         * ...for two-way binding.
         *
         * @name _openChanged
         * @type {EventEmitter<boolean>}
         * @memberof Wizard
         */
        this._openChanged = new EventEmitter(false);
        /**
         * Emits when the wizard is canceled. Can be observed through the clrWizardOnCancel
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultCancel input to create
         * wizard-level custom cancel routines.
         *
         * @name onCancel
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.onCancel = new EventEmitter(false);
        /**
         * Emits when the wizard is completed. Can be observed through the clrWizardOnFinish
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom completion routines.
         *
         * @name onFinish
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.wizardFinished = new EventEmitter(false);
        /**
         * Emits when the wizard is reset. See .reset(). Can be observed through
         * the clrWizardOnReset output.
         *
         * @name onReset
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.onReset = new EventEmitter(false);
        /**
         * Emits when the current page has changed. Can be observed through the clrWizardCurrentPageChanged
         * output. This can happen on .next() or .previous().
         * Useful for non-blocking validation.
         *
         * @name currentPageChanged
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.currentPageChanged = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the next page. Can be observed through the clrWizardOnNext
         * output.
         *
         * Can be combined with the clrWizardPreventDefaultNext input to create
         * wizard-level custom navigation routines, which are useful for validation.
         *
         * @name onMoveNext
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.onMoveNext = new EventEmitter(false);
        /**
         * Emits when the wizard moves to the previous page. Can be observed through the
         * clrWizardOnPrevious output.
         *
         * Can be useful for validation.
         *
         * @name onMovePrevious
         * @type {EventEmitter<any>}
         * @memberof Wizard
         */
        this.onMovePrevious = new EventEmitter(false);
        this._stopNext = false;
        this._stopCancel = false;
        this._stopNavigation = false;
        this._disableStepnav = false;
        /**
         * Used only to communicate to the underlying modal that animations are not
         * wanted. Primary use is for the display of static/inline wizards.
         *
         * Set using clrWizardPreventModalAnimation input. But you should never set it.
         *
         * @name _stopModalAnimations
         * @type {boolean}
         * @memberof Wizard
         */
        this._stopModalAnimations = false;
        this.goNextSubscription = this.navService.movedToNextPage.subscribe(function () {
            _this.onMoveNext.emit();
        });
        this.goPreviousSubscription = this.navService.movedToPreviousPage.subscribe(function () {
            _this.onMovePrevious.emit();
        });
        this.cancelSubscription = this.navService.notifyWizardCancel.subscribe(function () {
            _this.checkAndCancel();
        });
        this.wizardFinishedSubscription = this.navService.wizardFinished.subscribe(function () {
            if (!_this.stopNext) {
                _this.forceFinish();
            }
            _this.wizardFinished.emit();
        });
        this.differ = differs.find([]).create(null);
    }
    Object.defineProperty(Wizard.prototype, "forceForward", {
        get: function () {
            return this._forceForward;
        },
        /**
         * Resets page completed states when navigating backwards. Can be set using
         * the clrWizardForceForwardNavigation input.
         *
         * @name forceForward
         * @type {boolean}
         * @default false
         * @memberof Wizard
         */
        set: function (value) {
            this._forceForward = !!value;
            this.navService.forceForwardNavigation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "stopNext", {
        get: function () {
            return this._stopNext;
        },
        /**
         * Prevents Wizard from moving to the next page or closing itself on finishing.
         * Set using the clrWizardPreventDefaultNext input.
         *
         * Note that using stopNext will require you to create your own calls to
         * .next() and .finish() in your host component to make the Wizard work as
         * expected.
         *
         * Primarily used for validation.
         *
         * @name stopNext
         * @type {boolean}
         * @memberof Wizard
         */
        set: function (value) {
            this._stopNext = !!value;
            this.navService.wizardHasAltNext = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "stopCancel", {
        get: function () {
            return this._stopCancel;
        },
        /**
         * Prevents Wizard from closing when the cancel button or close "X" is clicked.
         * Set using the clrWizardPreventDefaultCancel input.
         *
         * Note that using stopCancel will require you to create your own calls to
         * .close() in your host component to make the Wizard work as expected.
         *
         * Useful for doing checks or prompts before closing a Wizard.
         *
         * @name stopCancel
         * @type {boolean}
         * @memberof Wizard
         */
        set: function (value) {
            this._stopCancel = !!value;
            this.navService.wizardHasAltCancel = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "stopNavigation", {
        get: function () {
            return this._stopNavigation;
        },
        /**
         * Prevents Wizard from performing any form of navigation away from the current
         * page. Set using the clrWizardPreventNavigation input.
         *
         * Note that stopNavigation is meant to freeze the wizard in place, typically
         * during a long validation or background action where you want the wizard to
         * display loading content but not allow the user to execute navigation in
         * the stepnav, close X, or the  back, finish, or next buttons.
         *
         * @name stopNavigation
         * @type {boolean}
         * @memberof Wizard
         */
        set: function (value) {
            this._stopNavigation = !!value;
            this.navService.wizardStopNavigation = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "disableStepnav", {
        get: function () {
            return this._disableStepnav;
        },
        /**
         * Prevents clicks on the links in the stepnav from working.
         *
         * A more granular bypassing of navigation which can be useful when your
         * Wizard is in a state of completion and you don't want users to be
         * able to jump backwards and change things.
         *
         * @name disableStepnav
         * @type {boolean}
         * @memberof Wizard
         */
        set: function (value) {
            this._disableStepnav = !!value;
            this.navService.wizardDisableStepnav = value;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "stopModalAnimations", {
        get: function () {
            if (this._stopModalAnimations) {
                return "true";
            }
            return "false";
        },
        enumerable: true,
        configurable: true
    });
    Wizard.prototype.ngOnInit = function () {
        var _this = this;
        this.currentPageSubscription = this.navService.currentPageChanged.subscribe(function (page) {
            _this.setGhostPages();
            _this.currentPageChanged.emit();
        });
    };
    Wizard.prototype.ngOnDestroy = function () {
        this.goNextSubscription.unsubscribe();
        this.goPreviousSubscription.unsubscribe();
        this.cancelSubscription.unsubscribe();
        this.currentPageSubscription.unsubscribe();
        this.wizardFinishedSubscription.unsubscribe();
    };
    /**
     * Sets up references that are needed by the providers.
     *
     * @name ngAfterContentInit
     * @memberof Wizard
     */
    Wizard.prototype.ngAfterContentInit = function () {
        var navService = this.navService;
        this.pageCollection.pages = this.pages;
        this.headerActionService.wizardHeaderActions = this.headerActions;
        if (this.showGhostPages) {
            navService.hideWizardGhostPages = false;
            this.deactivateGhostPages();
        }
    };
    /**
     * Used for keeping track of when pages are added or removed from this.pages
     *
     * @name ngDoCheck
     * @memberof Wizard
     */
    Wizard.prototype.ngDoCheck = function () {
        var _this = this;
        var changes = this.differ.diff(this.pages);
        if (changes) {
            changes.forEachAddedItem(function (r) {
                _this.navService.updateNavigation();
            });
            changes.forEachRemovedItem(function (r) {
                _this.navService.updateNavigation();
            });
        }
    };
    Object.defineProperty(Wizard.prototype, "isStatic", {
        /**
         * Convenient property for determining whether a wizard is static/in-line or not.
         *
         * @name isStatic
         * @readonly
         * @type {boolean}
         * @memberof Wizard
         */
        get: function () {
            return this.elementRef.nativeElement.classList.contains("clr-wizard--inline");
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "currentPage", {
        /**
         * As a getter, current page is a convenient way to retrieve the current page from
         * the WizardNavigationService.
         *
         * As a setter, current page accepts a WizardPage and passes it to WizardNavigationService
         * to be made the current page. currentPage performs checks to make sure it can navigate
         * to the designated page.
         *
         * @name currentPage
         * @type {WizardPage}
         * @memberof Wizard
         */
        get: function () {
            return this.navService.currentPage;
        },
        set: function (page) {
            this.navService.goTo(page, true);
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "isLast", {
        /**
         * Convenient property for determining if the current page is the last page of
         * the wizard.
         *
         * @name isLast
         * @readonly
         * @type {boolean}
         * @memberof Wizard
         */
        get: function () {
            return this.navService.currentPageIsLast;
        },
        enumerable: true,
        configurable: true
    });
    Object.defineProperty(Wizard.prototype, "isFirst", {
        /**
         * Convenient property for determining if the current page is the first page of
         * the wizard.
         *
         * @name isFirst
         * @readonly
         * @type {boolean}
         * @memberof Wizard
         */
        get: function () {
            return this.navService.currentPageIsFirst;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Performs the actions needed to open the wizard. If there is no current
     * page defined, sets the first page in the wizard to be current.
     *
     * @name open
     * @memberof Wizard
     */
    Wizard.prototype.open = function () {
        this._open = true;
        if (!this.currentPage) {
            this.navService.setFirstPageCurrent();
        }
        this.setGhostPages();
        this._openChanged.emit(true);
    };
    /**
     * Does the work involved with closing the wizard. Call this directly instead
     * of cancel() to implement alternative cancel functionality.
     *
     * @name close
     * @memberof Wizard
     */
    Wizard.prototype.close = function () {
        if (this.stopNavigation) {
            return;
        }
        this._open = false;
        this.deactivateGhostPages();
        this._openChanged.emit(false);
    };
    /**
     * Convenient function that can be used to open and close the wizard. It operates
     * by checking a Boolean parameter. If true, the wizard is opened. If false,
     * it is closed.
     *
     * There is no default value for this parameter, so by default the wizard will
     * close if invoked with no parameter.
     *
     * @name toggle
     * @param {boolean} value
     *
     * @memberof Wizard
     */
    Wizard.prototype.toggle = function (value) {
        if (value) {
            this.open();
        }
        else {
            this.close();
        }
    };
    /**
     * DEPRECATED. Moves the wizard to the previous page. Carried over from legacy.
     *
     * It is recommended that you use previous() instead.
     *
     * @name prev
     * @memberof Wizard
     */
    Wizard.prototype.prev = function () {
        this.previous();
    };
    /**
     * Moves the wizard to the previous page.
     *
     * @name previous
     * @memberof Wizard
     */
    Wizard.prototype.previous = function () {
        this.navService.previous();
    };
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will move to the next page regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * Generally, with alternative navigation, users are supplying their own checks
     * and validation. So there is no point in superseding their business logic
     * with our default behavior.
     *
     * If false, the wizard will execute default checks and emit events as normal.
     * This is useful for custom buttons or programmatic workflows that are not
     * executing the wizards default checks and emissions. It is another way to
     * navigate without having to rewrite the wizard’s default functionality
     * from scratch.
     *
     * By default, next() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * @name next
     * @memberof Wizard
     */
    Wizard.prototype.next = function (skipChecksAndEmits) {
        if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
        if (skipChecksAndEmits) {
            this.forceNext();
        }
        else {
            this.navService.next();
        }
    };
    /**
     * Includes a Boolean parameter that will skip checks and event emissions.
     * If true, the wizard will  complete and close regardless of the state of
     * its current page. This is useful for alternative navigation where event
     * emissions have already been done and firing them again may cause an event loop.
     *
     * If false, the wizard will execute default checks and emit events before
     * completing and closing.
     *
     * By default, finish() does not execute event emissions or checks because the
     * 80% case is that this method will be called as part of an alternative
     * navigation with clrWizardPreventDefaultNext.
     *
     * @name finish
     * @memberof Wizard
     */
    Wizard.prototype.finish = function (skipChecksAndEmits) {
        if (skipChecksAndEmits === void 0) { skipChecksAndEmits = true; }
        if (skipChecksAndEmits) {
            this.forceFinish();
        }
        else {
            this.navService.finish();
        }
    };
    /**
     * Does the work of finishing up the wizard and closing it but doesn't do the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling Wizard.finish(true) or Wizard.finish()
     * without a parameter.
     *
     * @name forceFinish
     * @memberof Wizard
     */
    Wizard.prototype.forceFinish = function () {
        if (this.stopNavigation) {
            return;
        }
        this.deactivateGhostPages();
        this.close();
    };
    /**
     * Does the work of moving the wizard to the next page without the
     * checks and emissions that other paths do. Good for a last step in an
     * alternate workflow.
     *
     * Does the same thing as calling Wizard.next(true) or Wizard.next()
     * without a parameter.
     *
     * @name forceNext
     * @memberof Wizard
     */
    Wizard.prototype.forceNext = function () {
        this.navService.forceNext();
    };
    /**
     * Initiates the functionality that cancels and closes the wizard.
     *
     * Do not use this for an override of the cancel the functionality
     * with clrWizardPreventDefaultCancel, clrWizardPreventPageDefaultCancel,
     * or clrWizardPagePreventDefault because it will initiate the same checks
     * and event emissions that invoked your event handler.
     *
     * Use Wizard.close() instead.
     *
     * @name cancel
     * @memberof Wizard
     */
    Wizard.prototype.cancel = function () {
        this.navService.cancel();
    };
    /**
     * Overrides behavior of the underlying modal to avoid collisions with
     * alternative cancel functionality.
     *
     * In most cases, use Wizard.cancel() instead.
     *
     * @name modalCancel
     * @memberof Wizard
     */
    Wizard.prototype.modalCancel = function () {
        this.checkAndCancel();
    };
    /**
     * Checks for alternative cancel flows defined at the current page or
     * wizard level. Performs a canceled if not. Emits events that initiate
     * the alternative cancel outputs (clrWizardPageOnCancel and
     * clrWizardOnCancel) if so.
     *
     * @name checkAndCancel
     * @memberof Wizard
     */
    Wizard.prototype.checkAndCancel = function () {
        var currentPage = this.currentPage;
        var currentPageHasOverrides = currentPage.stopCancel || currentPage.preventDefault;
        if (this.stopNavigation) {
            return;
        }
        currentPage.pageOnCancel.emit();
        if (!currentPageHasOverrides) {
            this.onCancel.emit();
        }
        if (!this.stopCancel && !currentPageHasOverrides) {
            this.close();
        }
    };
    /**
     * Accepts the wizard ID as a string parameter and calls to WizardNavigationService
     * to navigate to the page with that ID. Navigation will invoke the wizard’s default
     * checks and event emissions.
     *
     * Probably less useful than calling directly to Wizard.navService.goTo() because the
     * nav service method can accept either a string ID or a page object.
     *
     * The format of the expected ID parameter can be found in the return of the
     * WizardPage.id getter, usually prefixed with “clr-wizard-page-“ and then either a
     * numeric ID or the ID specified for the WizardPage component’s “id” input.
     *
     * @name goTo
     * @param {string} pageId
     * @returns {void}
     *
     * @memberof Wizard
     */
    Wizard.prototype.goTo = function (pageId) {
        if (!pageId) {
            return;
        }
        this.navService.goTo(pageId);
    };
    /**
     * A convenience function that calls to PageCollectionService.reset() and emits the
     * Wizard.onReset event.
     *
     * Reset sets all WizardPages to incomplete and sets the first page in the Wizard to
     * be the current page, essentially resetting the wizard navigation.
     *
     * Users would then use the onReset event to reset the data or model in their
     * host component.
     *
     * It could be useful to call a reset without firing the onReset event. To do this,
     * just call Wizard.pageCollection.reset() directly.
     *
     * @name reset
     * @memberof Wizard
     */
    Wizard.prototype.reset = function () {
        this.pageCollection.reset();
        this.onReset.next();
    };
    Object.defineProperty(Wizard.prototype, "ghostPageState", {
        /**
         * A convenience getter to retrieve the ghost Page animation state from
         * WizardNavigationService.
         *
         * @name ghostPageState
         * @readonly
         * @type {string}
         * @memberof Wizard
         */
        get: function () {
            return this.navService.wizardGhostPageState;
        },
        enumerable: true,
        configurable: true
    });
    /**
     * Convenience method that resets the ghost page animation.
     *
     * @name deactivateGhostPages
     * @memberof Wizard
     */
    Wizard.prototype.deactivateGhostPages = function () {
        this.setGhostPages("deactivate");
    };
    /**
     * Manages the state of the ghost page animation based on the location
     * of the current page in the workflow.
     *
     * Accepts an optional string parameter that can reset the ghost page
     * animation to its closed state.
     *
     * @name setGhostPages
     * @param {string} [deactivateOrNot=""]
     * @requires module:../modal/utils/ghost-page-animations
     * @requires ghost-page-animations#GHOST_PAGE_ANIMATION
     *
     * @memberof Wizard
     */
    Wizard.prototype.setGhostPages = function (deactivateOrNot) {
        if (deactivateOrNot === void 0) { deactivateOrNot = ""; }
        var navService = this.navService;
        var ghostpageStates = GHOST_PAGE_ANIMATION.STATES;
        if (this.showGhostPages) {
            if (deactivateOrNot === "deactivate") {
                navService.wizardGhostPageState = ghostpageStates.NO_PAGES;
            }
            else if (navService.currentPageIsLast) {
                navService.wizardGhostPageState = ghostpageStates.LAST_PAGE;
            }
            else if (navService.currentPageIsNextToLast) {
                navService.wizardGhostPageState = ghostpageStates.NEXT_TO_LAST_PAGE;
            }
            else {
                navService.wizardGhostPageState = ghostpageStates.ALL_PAGES;
            }
        }
    };
    return Wizard;
}());
export { Wizard };
Wizard.decorators = [
    { type: Component, args: [{
                selector: "clr-wizard",
                providers: [WizardNavigationService, PageCollectionService, ButtonHubService, HeaderActionService],
                template: "\n      <!--\n      ~ Copyright (c) 2016-2017 VMware, Inc. All Rights Reserved.\n      ~ This software is released under MIT license.\n      ~ The full license information can be found in LICENSE in the root directory of this project.\n      -->\n\n      <clr-modal \n          [clrModalOpen]=\"_open\"\n          [clrModalSize]=\"size\"\n          [clrModalClosable]=\"closable\"\n          [clrModalStaticBackdrop]=\"true\"\n          [clrModalSkipAnimation]=\"stopModalAnimations\"\n          [clrModalGhostPageState]=\"ghostPageState\"\n          [clrModalOverrideScrollService]=\"isStatic\"\n          [clrModalPreventClose]=\"true\"\n          (clrModalAlternateClose)=\"modalCancel()\">\n\n          <nav class=\"modal-nav clr-wizard-stepnav-wrapper\">\n              <h3 class=\"clr-wizard-title\"><ng-content select=\"clr-wizard-title\"></ng-content></h3>\n              <clr-wizard-stepnav></clr-wizard-stepnav>\n          </nav>\n\n          <h3 class=\"modal-title\">\n              <span class=\"modal-title-text\">\n                  <ng-template [ngTemplateOutlet]=\"navService.currentPageTitle\"></ng-template>\n              </span>\n\n              <div class=\"modal-header-actions-wrapper\" *ngIf=\"headerActionService.displayHeaderActionsWrapper\">\n                  <div *ngIf=\"headerActionService.showWizardHeaderActions\">\n                      <ng-content select=\"clr-wizard-header-action\"></ng-content>\n                  </div>\n                  <div *ngIf=\"headerActionService.currentPageHasHeaderActions\">\n                      <ng-template [ngTemplateOutlet]=\"navService.currentPage.headerActions\"></ng-template>\n                  </div>\n              </div>\n          </h3>\n\n          <div class=\"modal-body\">\n              <main clr-wizard-pages-wrapper class=\"clr-wizard-content\">\n                  <ng-content></ng-content>\n              </main>\n          </div>\n          <div class=\"modal-footer clr-wizard-footer\">\n              <div class=\"clr-wizard-footer-buttons\">\n                  <div *ngIf=\"navService.currentPage && !navService.currentPage.hasButtons\"\n                      class=\"clr-wizard-footer-buttons-wrapper\">\n                      <ng-content select=\"clr-wizard-button\"></ng-content>\n                  </div>\n                  <div *ngIf=\"navService.currentPage && navService.currentPage.hasButtons\"\n                      class=\"clr-wizard-footer-buttons-wrapper\">\n                      <ng-template [ngTemplateOutlet]=\"navService.currentPage.buttons\"></ng-template>\n                  </div>\n              </div>\n          </div>\n      </clr-modal>\n    ",
                host: {
                    "[class.clr-wizard]": "true",
                    "[class.wizard-md]": "size == 'md'",
                    "[class.wizard-lg]": "size == 'lg'",
                    "[class.wizard-xl]": "size == 'xl'",
                    "[class.lastPage]": "navService.currentPageIsLast",
                    "[class.clr-wizard--ghosted]": "showGhostPages"
                }
            },] },
];
/** @nocollapse */
Wizard.ctorParameters = function () { return [
    { type: WizardNavigationService, },
    { type: PageCollectionService, },
    { type: ButtonHubService, },
    { type: HeaderActionService, },
    { type: ElementRef, },
    { type: IterableDiffers, },
]; };
Wizard.propDecorators = {
    'size': [{ type: Input, args: ["clrWizardSize",] },],
    'showGhostPages': [{ type: Input, args: ["clrWizardShowGhostPages",] },],
    'forceForward': [{ type: Input, args: ["clrWizardForceForwardNavigation",] },],
    'closable': [{ type: Input, args: ["clrWizardClosable",] },],
    '_open': [{ type: Input, args: ["clrWizardOpen",] },],
    '_openChanged': [{ type: Output, args: ["clrWizardOpenChange",] },],
    'onCancel': [{ type: Output, args: ["clrWizardOnCancel",] },],
    'wizardFinished': [{ type: Output, args: ["clrWizardOnFinish",] },],
    'onReset': [{ type: Output, args: ["clrWizardOnReset",] },],
    'pages': [{ type: ContentChildren, args: [WizardPage,] },],
    'headerActions': [{ type: ContentChildren, args: [WizardHeaderAction,] },],
    'currentPageChanged': [{ type: Output, args: ["clrWizardCurrentPageChanged",] },],
    'onMoveNext': [{ type: Output, args: ["clrWizardOnNext",] },],
    'onMovePrevious': [{ type: Output, args: ["clrWizardOnPrevious",] },],
    'stopNext': [{ type: Input, args: ["clrWizardPreventDefaultNext",] },],
    'stopCancel': [{ type: Input, args: ["clrWizardPreventDefaultCancel",] },],
    'stopNavigation': [{ type: Input, args: ["clrWizardPreventNavigation",] },],
    'disableStepnav': [{ type: Input, args: ["clrWizardDisableStepnav",] },],
    '_stopModalAnimations': [{ type: Input, args: ["clrWizardPreventModalAnimation",] },],
};
//# sourceMappingURL=wizard.js.map